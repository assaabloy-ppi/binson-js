import Binson from './../src/binson.js';
const test = typeof module !== 'undefined' && module.exports ? require('./tape.js') : self.test;

// Tests for binson.js.
// Run tests with code: [runBinsonTests()]. See JavaScript console for output.
//
// Authors: Frans Lundberg, Felix Grape & HÃ¥kan Olsson
//

// ======== Functions ========
function bufferToArray(buffer) {
	return new Uint8Array(buffer);
}

// See README.txt for more information
// VALUE TESTS START HERE
test('Bytes', function(t) {
	const expectedA = [0x40, 0x14, 0x01, 0x61, 0x18, 0x04, 0x00, 0x00, 0x00, 0x00, 0x41];
	const expectedB = [0x40, 0x14, 0x01, 0x61, 0x18, 0x04, 0x00, 0x01, 0x02, 0x03, 0x41];

	const a = new ArrayBuffer(4);
	const b = new ArrayBuffer(4);
	const u8 = new Uint8Array(b);
	u8[0] = 0;
	u8[1] = 1;
	u8[2] = 2;
	u8[3] = 3;

	const binA = new Binson().putBytes("a", a);
	const binB = new Binson().putBytes("a", b);

	t.true(binA.hasBytes("a"), "Field a found") ;
	t.deepEqual(bufferToArray(binA.toBytes()), expectedA);
	t.true(binA.getBytes('a') !== null, "Can get byte");
    t.false(binA.hasBytes("B"), "Field B not found");

    t.true(binB.hasBytes("a"), "Field a found") ;
    t.deepEqual(bufferToArray(binB.toBytes()), expectedB);
	t.true(binB.getBytes('a') !== null, "Can get byte");
    t.false(binB.hasBytes("B"), "Field B not found");

    t.end();
});

test('BytesLong', function(t) {
	const expectedA = [0x40, 0x14, 0x01, 0x61, 0x19, 0x80, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41];

	const expectedB = [0x40, 0x14, 0x01, 0x61, 0x19, 0x80, 0x00,
					0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
					0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
					0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
					0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
					0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
					0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
					0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
					0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
					0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
					0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
					0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
					0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
					0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x41];

	const data = [0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
				0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
				0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
				0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
				0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
				0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
				0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
				0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
				0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
				0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
				0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
				0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
				0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38];

	const a = new ArrayBuffer(128);
	const b = new ArrayBuffer(128);
	const u8 = new Uint8Array(b);

	for (let i = 0; i < b.byteLength; i++) {
		u8[i] = data[i];
	}

	const binA = new Binson().putBytes("a", a);
	const binB = new Binson().putBytes("a", b);

	const bytesA = binA.toBytes();
	const bytesB = binB.toBytes();

	t.deepEqual(bufferToArray(bytesA), expectedA);
	t.deepEqual(bufferToArray(bytesB), expectedB);

	t.end();
});

// Throws error! Putting a string with putBytes should not work!
test('BytesString', function(t) {
	let exception = false;
	try {
		new Binson().putBytes("a", "a");
	} catch (err) {
		exception = true;
	}
	if (!exception) {
		throw new Error("Able to put string with putBytes");
	}

	t.end();
});

test('String', function(t) {
	const expected = [0x40, 0x14, 0x01, 0x61, 0x14, 0x01, 0x62, 0x41];
	const b = new Binson().putString("a", "b");
	const bytes = b.toBytes();

	t.deepEqual(bufferToArray(bytes), expected);

	if (b.hasString("a")) {
		const res = b.getString("a");
		if (res !== "b") {
			throw new Error("Field value not as expected");
		}
	} else {
		throw new Error("Field a not found");
	}

	if (b.hasString("B")) {
		throw new Error("Field B found");
	}

	t.end();
});

test('StringEmoji', function(t) {
	const expected = [0x40, 0x14, 0x01, 0x61, 0x14, 0x04, 0xF0, 0x9F, 0x98, 0x82, 0x41];
	const b = new Binson().putString("a", "ðŸ˜‚");
	const bytes = b.toBytes();

	t.deepEqual(bufferToArray(bytes), expected);

	if (b.hasString("a")) {
		let res = b.getString("a");
		if (res !== "ðŸ˜‚") {
			throw new Error("Field value not as expected");
		}
	} else {
		throw new Error("Field a not found");
	}

	t.end();
});

test('StringLong', function(t) {
	const expected = [0x40, 0x14, 0x01, 0x61, 0x15, 0x80, 0x00,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x41];

	let str = "";
	str += "12345678901234567890123456789012345678901234567890";
	str += "12345678901234567890123456789012345678901234567890";
	str += "1234567890123456789012345678";

	const b = new Binson().putString("a", str);
	const bytes = b.toBytes();

	t.deepEqual(bufferToArray(bytes), expected);

	t.end();
});

// Throws error! Putting a boolean with putString should not work!
test('StringBoolean', function(t) {
	let exception = false;
	try {
		new Binson().putString("a", true);
	} catch (err) {
		exception = true;
	}
	if (!exception) {
		throw new Error("Able to put boolean with putString");
	}

	t.end();
});

test('Boolean', function(t) {
	const expectedA = [0x40, 0x14, 0x01, 0x61, 0x44, 0x41];
	const expectedB = [0x40, 0x14, 0x01, 0x61, 0x45, 0x41];

	const binA = new Binson().putBoolean("a", true);
	const binB = new Binson().putBoolean("a", false);

	const bytesA = binA.toBytes();
	const bytesB = binB.toBytes();

	t.deepEqual(bufferToArray(bytesA), expectedA);
	t.deepEqual(bufferToArray(bytesB), expectedB);

	if (binA.hasBoolean("a")) {
		const res = binA.getBoolean("a");
		if (res !== true) {
			throw new Error("Field value not as expected");
		}
	} else {
		throw new Error("Field a not found");
	}

	if (binA.hasBoolean("B")) {
		throw new Error("Field B found");
	}

	t.end();
});

// Throws error! Putting a double with putBoolean should not work!
test('BooleanDouble', function(t) {
	let exception = false;
	try {
		new Binson().putBoolean("a", Math.PI);
	} catch (err) {
		exception = true;
	}
	if (!exception) {
		throw new Error("Able to put double with putBoolean");
	}

	t.end();
});

// Test edge cases: (bitpatterns are big-endian)
// Bitpattern:  0..0	01..1	   		10..0
// Decimal:		0		127 (2^7-1)		-128 (-2^7)
// Hexadecimal:	0x00	0x7F			0x80
test('Int8', function(t) {
	const expectedA = [0x40, 0x14, 0x01, 0x61, 0x10, 0x00, 0x41];
	const expectedB = [0x40, 0x14, 0x01, 0x61, 0x10, 0x7F, 0x41];
	const expectedC = [0x40, 0x14, 0x01, 0x61, 0x10, 0x80, 0x41];

	const a = 0;
	const b = 127;
	const c = -128;

	const binA = new Binson().putInteger("a", a);
	const binB = new Binson().putInteger("a", b);
	const binC = new Binson().putInteger("a", c);

	const bytesA = binA.toBytes();
	const bytesB = binB.toBytes();
	const bytesC = binC.toBytes();

	t.deepEqual(bufferToArray(bytesA), expectedA);
	t.deepEqual(bufferToArray(bytesB), expectedB);
	t.deepEqual(bufferToArray(bytesC), expectedC);

	if (binA.hasInteger("a")) {
		const res = binA.getInteger("a");
		if (res !== a) {
			throw new Error("Field value not as expected");
		}
	} else {
		throw new Error("Field a not found");
	}

	if (binA.hasInteger("B")) {
		throw new Error("Field B found");
	}

	t.end();
});

// Test edge cases:	(bitpatterns and hex are big-endian)
// Bitpattern:	0..0 10..0		1..1 01..1		10..0 0..0		01..1 1..1
// Decimal		128 (2^7)		-129 (-2^7-1)	-32768 (-2^15)	32767 (2^15-1)
// Hexadecimal:	0x0080			0xFF7F			0x8000			0x7FFF
test('Int16', function(t) {
	const expectedA = [0x40, 0x14, 0x01, 0x61, 0x11, 0x80, 0x00, 0x41];
	const expectedB = [0x40, 0x14, 0x01, 0x61, 0x11, 0x7F, 0xFF, 0x41];
	const expectedC = [0x40, 0x14, 0x01, 0x61, 0x11, 0x00, 0x80, 0x41];
	const expectedD = [0x40, 0x14, 0x01, 0x61, 0x11, 0xFF, 0x7F, 0x41];

	const a = 128;
	const b = -129;
	const c = -32768;
	const d = 32767;

	const binA = new Binson().putInteger("a", a);
	const binB = new Binson().putInteger("a", b);
	const binC = new Binson().putInteger("a", c);
	const binD = new Binson().putInteger("a", d);

	const bytesA = binA.toBytes();
	const bytesB = binB.toBytes();
	const bytesC = binC.toBytes();
	const bytesD = binD.toBytes();

	t.deepEqual(bufferToArray(bytesA), expectedA);
	t.deepEqual(bufferToArray(bytesB), expectedB);
	t.deepEqual(bufferToArray(bytesC), expectedC);
	t.deepEqual(bufferToArray(bytesD), expectedD);

	t.end();
});

// Test edge cases:	(bitpatterns are big-endian)
// Bitpattern:  0..0 0..0 10..0 0..0	1..1 1..1 01..1 1..1	10..0 0..0 0..0 0..0	01..1 1..1 1..1 1..1
// Decimal:	 	32768 (2^15)			-32769 (-2^15-1)		-2147483648 (-2^31)		2147483647 (2^31-1)
// Hexadecimal:	0x00008000				0xFFFF7FFF				0x80000000				0x7FFFFFFF
test('Int32', function(t) {
	const expectedA = [0x40, 0x14, 0x01, 0x61, 0x12, 0x00, 0x80, 0x00, 0x00, 0x41];
	const expectedB = [0x40, 0x14, 0x01, 0x61, 0x12, 0xFF, 0x7F, 0xFF, 0xFF, 0x41];
	const expectedC = [0x40, 0x14, 0x01, 0x61, 0x12, 0x00, 0x00, 0x00, 0x80, 0x41];
	const expectedD = [0x40, 0x14, 0x01, 0x61, 0x12, 0xFF, 0xFF, 0xFF, 0x7F, 0x41];

	const a = 32768;
	const b = -32769;
	const c = -2147483648;
	const d = 2147483647;

	const binA = new Binson().putInteger("a", a);
	const binB = new Binson().putInteger("a", b);
	const binC = new Binson().putInteger("a", c);
	const binD = new Binson().putInteger("a", d);

	const bytesA = binA.toBytes();
	const bytesB = binB.toBytes();
	const bytesC = binC.toBytes();
	const bytesD = binD.toBytes();

	t.deepEqual(bufferToArray(bytesA), expectedA);
	t.deepEqual(bufferToArray(bytesB), expectedB);
	t.deepEqual(bufferToArray(bytesC), expectedC);
	t.deepEqual(bufferToArray(bytesD), expectedD);

	t.end();
});

test('Int53', function(t) {
	const expectedA = [0x40, 0x14, 0x01, 0x61, 0x13, 0x01, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x41];
	const expectedB = [0x40, 0x14, 0x01, 0x61, 0x13, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x41];
	const expectedC = [0x40, 0x14, 0x01, 0x61, 0x13, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x41];

	const a = 2147483649;
	const b = 9007199254740990; // Number.MAX_SAFE_INTEGER = 9007199254740991
	const c = 9007199254740991;

	const binA = new Binson().putInteger("a", a);
	const binB = new Binson().putInteger("a", b);
	const binC = new Binson().putInteger("a", c);

	const bytesA = binA.toBytes();
	const bytesB = binB.toBytes();
	const bytesC = binC.toBytes();

	t.deepEqual(bufferToArray(bytesA), expectedA);
	t.deepEqual(bufferToArray(bytesB), expectedB);
	t.deepEqual(bufferToArray(bytesC), expectedC);

	t.end();
});

test('Int64Pos', function(t) {
	let exception = false;
	try {
		new Binson().putInteger("a", 9223372036854775807);
	} catch (err) {
		exception = true;
	}
	if (!exception) {
		throw new Error("Able to put 2^63-1 with putInteger");
	}

	t.end();
});

// Throws error! Only 32-bit integers are supported in binson.js
test('Int64Neg', function(t) {
	let exception = false;
	try {
		new Binson().putInteger("a", -9223372036854775808);
	} catch (err) {
		exception = true;
	}
	if (!exception) {
		throw new Error("Able to put -2^63 with putInteger");
	}

	t.end();
});

// Throws error! You can only put integers with putInteger
test('IntDouble', function(t) {
	let exception = false;
	try {
		new Binson().putInteger("a", Math.PI);
	} catch (err) {
		exception = true;
	}
	if (!exception) {
		throw new Error("Able to put double with putInteger");
	}

	t.end();
});

// See http://www.exploringbinary.com/floating-point-converter/
// in order to generate bitpatterns for 64-bit floats
test('Double', function(t) {
	const expectedA = [0x40, 0x14, 0x01, 0x61, 0x46, 0xBA, 0x17, 0x06, 0x3d, 0x55, 0x55, 0x55, 0xBD, 0x41];
	const expectedB = [0x40, 0x14, 0x01, 0x61, 0x46, 0xB5, 0x69, 0xA5, 0xE6, 0x87, 0x95, 0x75, 0x40, 0x41];

	const a = -3.0316488E-13;		// 0xBD5555553D0617BA
	const b = 345.3456789456789;	// 0x40759587E6A569B5

	const binA = new Binson().putDouble("a", a);
	const binB = new Binson().putDouble("a", b);

	const bytesA = binA.toBytes();
	const bytesB = binB.toBytes();

	t.deepEqual(bufferToArray(bytesA), expectedA);
	t.deepEqual(bufferToArray(bytesB), expectedB);

	if (binA.hasDouble("a")) {
		const res = binA.getDouble("a");
		if (res !== a) {
			throw new Error("Field value not as expected");
		}
	} else {
		throw new Error("Field a not found");
	}

	if (binA.hasDouble("B")) {
		throw new Error("Field B found");
	}

	t.end();
});

// Throws error! Putting an ArrayBuffer with putDouble should not work
test('DoubleBytes', function(t) {
	let exception = false;
	try {
		new Binson().putDouble("a", new ArrayBuffer(10));
	} catch (err) {
		exception = true;
	}
	if (!exception) {
		throw new Error("Able to put array with putDouble");
	}

	t.end();
});

test('ArrayEmpty', function(t) {
	const expected = [0x40, 0x14, 0x01, 0x61, 0x42, 0x43, 0x41];

	const a = [];

	const b = new Binson().putArray("a", a);
	const bytes = b.toBytes();

	t.true(b.hasArray("a"), "Field a found") ;
	t.deepEqual(bufferToArray(bytes), expected);
	t.true(b.getArray('a') !== null, "Can get byte");
	t.false(b.hasArray("B"), "Field B not found");

	t.end();
});

test('ArrayBoolean', function(t) {
	const expectedA = [0x40, 0x14, 0x01, 0x61, 0x42, 0x44, 0x43, 0x41];
	const expectedB = [0x40, 0x14, 0x01, 0x61, 0x42, 0x45, 0x43, 0x41];

	const a = [true];
	const b = [false];

	const binA = new Binson().putArray("a", a);
	const binB = new Binson().putArray("a", b);

	const bytesA = binA.toBytes();
	const bytesB = binB.toBytes();

	t.deepEqual(bufferToArray(bytesA), expectedA);
	t.deepEqual(bufferToArray(bytesB), expectedB);

	t.end();
});

test('ArrayInt8', function(t) {
	const expectedA = [0x40, 0x14, 0x01, 0x61, 0x42, 0x10, 0x00, 0x43, 0x41];
	const expectedB = [0x40, 0x14, 0x01, 0x61, 0x42, 0x10, 0x80, 0x43, 0x41];
	const expectedC = [0x40, 0x14, 0x01, 0x61, 0x42, 0x10, 0x7F, 0x43, 0x41];

	const a = [0];
	const b = [-128];
	const c = [127];

	const binA = new Binson().putArray("a", a);
	const binB = new Binson().putArray("a", b);
	const binC = new Binson().putArray("a", c);

	const bytesA = binA.toBytes();
	const bytesB = binB.toBytes();
	const bytesC = binC.toBytes();

	t.deepEqual(bufferToArray(bytesA), expectedA);
	t.deepEqual(bufferToArray(bytesB), expectedB);
	t.deepEqual(bufferToArray(bytesC), expectedC);

	t.end();
});

test('ArrayInt16', function(t) {
	const expectedA = [0x40, 0x14, 0x01, 0x61, 0x42, 0x11, 0x80, 0x00, 0x43, 0x41];
	const expectedB = [0x40, 0x14, 0x01, 0x61, 0x42, 0x11, 0x00, 0x80, 0x43, 0x41];
	const expectedC = [0x40, 0x14, 0x01, 0x61, 0x42, 0x11, 0x7F, 0xFF, 0x43, 0x41];
	const expectedD = [0x40, 0x14, 0x01, 0x61, 0x42, 0x11, 0xFF, 0x7F, 0x43, 0x41];

	const a = [128];
	const b = [-32768];
	const c = [-129];
	const d = [32767];

	const binA = new Binson().putArray("a", a);
	const binB = new Binson().putArray("a", b);
	const binC = new Binson().putArray("a", c);
	const binD = new Binson().putArray("a", d);

	const bytesA = binA.toBytes();
	const bytesB = binB.toBytes();
	const bytesC = binC.toBytes();
	const bytesD = binD.toBytes();

	t.deepEqual(bufferToArray(bytesA), expectedA);
	t.deepEqual(bufferToArray(bytesB), expectedB);
	t.deepEqual(bufferToArray(bytesC), expectedC);
	t.deepEqual(bufferToArray(bytesD), expectedD);

	t.end();
});

test('ArrayInt32', function(t) {
	const expectedA = [0x40, 0x14, 0x01, 0x61, 0x42, 0x12, 0x00, 0x80, 0x00, 0x00, 0x43, 0x41];
	const expectedB = [0x40, 0x14, 0x01, 0x61, 0x42, 0x12, 0xFF, 0x7F, 0xFF, 0xFF, 0x43, 0x41];
	const expectedC = [0x40, 0x14, 0x01, 0x61, 0x42, 0x12, 0x00, 0x00, 0x00, 0x80, 0x43, 0x41];
	const expectedD = [0x40, 0x14, 0x01, 0x61, 0x42, 0x12, 0xFF, 0xFF, 0xFF, 0x7F, 0x43, 0x41];

	const a = [32768];
	const b = [-32769];
	const c = [-2147483648];
	const d = [2147483647];

	const binA = new Binson().putArray("a", a);
	const binB = new Binson().putArray("a", b);
	const binC = new Binson().putArray("a", c);
	const binD = new Binson().putArray("a", d);

	const bytesA = binA.toBytes();
	const bytesB = binB.toBytes();
	const bytesC = binC.toBytes();
	const bytesD = binD.toBytes();

	t.deepEqual(bufferToArray(bytesA), expectedA);
	t.deepEqual(bufferToArray(bytesB), expectedB);
	t.deepEqual(bufferToArray(bytesC), expectedC);
	t.deepEqual(bufferToArray(bytesD), expectedD);

	t.end();
});

// Throws error! Binson.js cannot handle 64-bit integers
test('ArrayInt64Pos', function(t) {
	let exception = false;
	try {
		new Binson().putArray("a", [9223372036854775807]);
	} catch (err) {
		exception = true;
	}
	if (!exception) {
		throw new Error("Able to put 64 bit integer in array");
	}

	t.end();
});

// Throws error! Binson.js cannot handle 64-bit integers
test('ArrayInt64Neg', function(t) {
	let exception = false;
	try {
		new Binson().putArray("a", [-9223372036854775807]);
	} catch (err) {
		exception = true;
	}
	if (!exception) {
		throw new Error("Able to put 64 bit integer in array");
	}

	t.end();
});

test('ArrayInts', function(t) {
	const expected = [0x40, 0x14, 0x01, 0x61, 0x42,
					0x10, 0x7F,						// int8		127
					0x11, 0xFF, 0x7F,				// int16	32767
					0x12, 0xFF, 0xFF, 0xFF, 0x7F,	// int32	2147483647
					0x43, 0x41];

	const a = [127, 32767, 2147483647];
	const b = new Binson().putArray("a", a);
	const bytes = b.toBytes();

	t.deepEqual(bufferToArray(bytes), expected);

	t.end();
});

// See: http://www.exploringbinary.com/floating-point-converter/
// in order to generate bitpatterns for 64-bit floats
test('ArrayDouble', function(t) {
	const expectedA = [0x40, 0x14, 0x01, 0x61, 0x42, 0x46, 0xBA, 0x17,
						0x06, 0x3d, 0x55, 0x55, 0x55, 0xBD, 0x43, 0x41];
	const expectedB = [0x40, 0x14, 0x01, 0x61, 0x42, 0x46, 0xB5, 0x69,
						0xA5, 0xE6, 0x87, 0x95, 0x75, 0x40, 0x43, 0x41];

	const a = [-3.0316488E-13];
	const b = [345.3456789456789];

	const binA = new Binson().putArray("a", a);
	const binB = new Binson().putArray("a", b);

	const bytesA = binA.toBytes();
	const bytesB = binB.toBytes();

	t.deepEqual(bufferToArray(bytesA), expectedA);
	t.deepEqual(bufferToArray(bytesB), expectedB);

	t.end();
});

// See: http://www.exploringbinary.com/floating-point-converter/
// in order to generate bitpatterns for 64-bit floats
test('ArrayDoubles', function(t) {
	const expected = [0x40, 0x14, 0x01, 0x61, 0x42,
					0x46, 0xBA, 0x17, 0x06, 0x3d, 0x55, 0x55, 0x55, 0xBD, 	// First double		-3.0316488E-13
					0x46, 0xB5, 0x69, 0xA5, 0xE6, 0x87, 0x95, 0x75, 0x40,	// Second double	345.3456789456789
					0x46, 0x18, 0x2D, 0x44, 0x54, 0xFB, 0x21, 0x09, 0x40,	// Third double		Math.PI (3.141592653589793)
					0x43, 0x41];

	const a = [-3.0316488E-13, 345.3456789456789, Math.PI];
	const b = new Binson().putArray("a", a);
	const bytes = b.toBytes();

	t.deepEqual(bufferToArray(bytes), expected);

	t.end();
});

test('ArrayString', function(t) {
	const expected = [0x40, 0x14, 0x01, 0x61, 0x42, 0x14, 0x01, 0x62, 0x43, 0x41];
	const a = ["b"];

	const b = new Binson().putArray("a", a);
	const bytes = b.toBytes();

	t.deepEqual(bufferToArray(bytes), expected);

	t.end();
});

test('ArrayStringLong', function(t) {
	const expected = [0x40, 0x14, 0x01, 0x61, 0x42, 0x15, 0x80, 0x00,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x43, 0x41];

	let str = "";
	str += "12345678901234567890123456789012345678901234567890";
	str += "12345678901234567890123456789012345678901234567890";
	str += "1234567890123456789012345678";

	const a = [str];

	const b = new Binson().putArray("a", a);
	const bytes = b.toBytes();

	t.deepEqual(bufferToArray(bytes), expected);

	t.end();
});

test('ArrayObject', function(t) {
	const expectedA = [0x40, 0x14, 0x01, 0x61, 0x42,
					0x40, 0x41, 							// Binson object without fields
					0x43, 0x41];
	const expectedB = [0x40, 0x14, 0x01, 0x61, 0x42,
					0x40, 0x14, 0x01, 0x61, 0x44, 0x41, 	// Binson object with a boolean field a = true
					0x43, 0x41];

	const a = [new Binson()];
	const b = [new Binson().putBoolean("a", true)];

	const binA = new Binson().putArray("a", a);
	const binB = new Binson().putArray("a", b);

	const bytesA = binA.toBytes();
	const bytesB = binB.toBytes();

	t.deepEqual(bufferToArray(bytesA), expectedA);
	t.deepEqual(bufferToArray(bytesB), expectedB);

	t.end();
});

test('ArrayObjects', function(t) {
	const expected = [0x40, 0x14, 0x01, 0x61, 0x42,
					0x40, 0x41,									// Binson object without fields
					0x40, 0x14, 0x01, 0x61, 0x44, 0x41,			// Binson object with a boolean field a = true
					0x40, 0x14, 0x01, 0x62, 0x40, 0x41, 0x41,	// Binson object with a object field b, object without fields
					0x43, 0x41];

	const a = [];
	a.push(new Binson());
	a.push(new Binson().putBoolean("a", true));
	a.push(new Binson().putObject("b", new Binson()));

	const b = new Binson().putArray("a", a);
	const bytes = b.toBytes();

	t.deepEqual(bufferToArray(bytes), expected);

	t.end();
});

test('ArrayBytes', function(t) {
	const expectedA = [0x40, 0x14, 0x01, 0x61, 0x42, 0x18, 0x04, 0x00, 0x00, 0x00, 0x00, 0x43, 0x41];
	const expectedB = [0x40, 0x14, 0x01, 0x61, 0x42, 0x18, 0x04, 0x00, 0x01, 0x02, 0x03, 0x43, 0x41];

	const aBuff = new ArrayBuffer(4);
	const bBuff = new ArrayBuffer(4);
	const u8 = new Uint8Array(bBuff);
	u8[0] = 0;
	u8[1] = 1;
	u8[2] = 2;
	u8[3] = 3;

	const a = [aBuff];
	const b = [bBuff];

	const binA = new Binson().putArray("a", a);
	const binB = new Binson().putArray("a", b);

	const bytesA = binA.toBytes();
	const bytesB = binB.toBytes();

	t.deepEqual(bufferToArray(bytesA), expectedA);
	t.deepEqual(bufferToArray(bytesB), expectedB);

	t.end();
});

test('ArrayBytesLong', function(t) {
	const expectedA = [0x40, 0x14, 0x01, 0x61, 0x42, 0x19, 0x80, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x41];

	const expectedB = [0x40, 0x14, 0x01, 0x61, 0x42, 0x19, 0x80, 0x00,
					0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
					0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
					0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
					0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
					0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
					0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
					0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
					0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
					0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
					0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
					0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
					0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
					0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x43, 0x41];

	const data = [0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
				0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
				0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
				0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
				0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
				0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
				0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
				0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
				0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
				0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
				0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
				0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
				0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38];

	const aBuff = new ArrayBuffer(128);
	const bBuff = new ArrayBuffer(128);
	const u8 = new Uint8Array(bBuff);

	for (let i = 0; i < data.length; i++) {
		u8[i] = data[i];
	}

	const a = [aBuff];
	const b = [bBuff];

	const binA = new Binson().putArray("a", a);
	const binB = new Binson().putArray("a", b);

	const bytesA = binA.toBytes();
	const bytesB = binB.toBytes();

	t.deepEqual(bufferToArray(bytesA), expectedA);
	t.deepEqual(bufferToArray(bytesB), expectedB);

	t.end();
});

test('ArrayNested', function(t) {
	const expectedA = [0x40, 0x14, 0x01, 0x61, 0x42, 0x42, 0x43, 0x43, 0x41];
	const expectedB = [0x40, 0x14, 0x01, 0x61, 0x42, 0x42, 0x44, 0x45, 0x43, 0x43, 0x41];

	const a = [[]];
	const b = [[true, false]];

	const binA = new Binson().putArray("a", a);
	const binB = new Binson().putArray("a", b);

	const bytesA = binA.toBytes();
	const bytesB = binB.toBytes();

	t.deepEqual(bufferToArray(bytesA), expectedA);
	t.deepEqual(bufferToArray(bytesB), expectedB);

	t.end();
});

// Throws error! Binson does not support null.
test('ArrayNull', function(t) {
	let exception = false;
	try {
		new Binson().putArray("a", [1, 2, null, 3]);
	} catch (err) {
		exception = true;
	}
	if (!exception) {
		throw new Error("Able to put null element in array");
	}

	t.end();
});

// Throws error! Undefined is an invalid array element
test('ArrayNestedUndefined', function(t) {
	// arr[1][1][2] = undefined
	let exception = false;
	try {
		new Binson().putArray("a", [true, [Math.PI, [0, 0, undefined]], false, [1,[],new Binson()]]);
	} catch (err) {
		exception = true;
	}
	if (!exception) {
		throw new Error("Able to put undefined element in nested array");
	}

	t.end();
});

test('ObjectEmpty', function(t) {
	const a = new Binson().putObject("b", new Binson());
	const expected = [0x40, 0x14, 0x01, 0x62, 0x40, 0x41, 0x41];
	const bytes = a.toBytes();

	t.deepEqual(bufferToArray(bytes), expected);

	t.end();
});

test('ObjectInteger', function(t) {
	const expected = [0x40, 0x14, 0x01, 0x61, 0x40, 0x14, 0x01, 0x61, 0x10, 0x00, 0x41, 0x41];

	const bInner = new Binson().putInteger("a", 0);
	const b = new Binson().putObject("a", bInner);
	const bytes = b.toBytes();

	t.deepEqual(bufferToArray(bytes), expected);

	t.end();
});

// PROPERTY TESTS START
test('EmptyObject', function(t) {
	const expected = [0x40, 0x41];
	const bytes = new Binson().toBytes();
	t.deepEqual(bufferToArray(bytes), expected);

	t.end();
});

test('Ordering', function(t) {
	// k12 and k2 in lexicographical order here
	const expected = [0x40, 0x14, 0x03, 0x6B, 0x31, 0x32, 0x14, 0x02, 0x76, 0x31,
					0x14, 0x02, 0x6B, 0x32, 0x14, 0x02, 0x76, 0x32, 0x41];

	// k12 and k2 not in lexicographical order here
	const b = new Binson().putString("k2", "v2").putString("k12", "v1");

	// toBytes has to put k12 before k2
	const bytes = b.toBytes();

	t.deepEqual(bufferToArray(bytes), expected);

	t.end();
});

test('NameUnique', function(t) {
	// Make sure a2 overwrites a1
	const expected = [0x40, 0x14, 0x01, 0x61, 0x10, 0x00, 0x41];
	const a1 = true;
	const a2 = 0;

	const b = new Binson();

	b.putBoolean("a", a1); 	// bytes of b: [0x40, 0x14, 0x01, 0x61, 0x10, 0x0A, 0x41];
	b.putInteger("a", a2);

	const bytes = b.toBytes();

	t.deepEqual(bufferToArray(bytes), expected);

	t.end();
});
